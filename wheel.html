<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wheel o' Whatever</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Orbitron', sans-serif;
            background-color: #0b1021;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }

        /* Background Particles */
        #particleCanvas {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: -1; opacity: 0.6;
        }

        .wheel-wrapper {
            position: relative;
            width: 90vw; height: 90vw;
            max-width: 450px; max-height: 450px;
            margin: 20px;
        }

        canvas {
            width: 100%; height: 100%;
            filter: drop-shadow(0 0 20px rgba(0,0,0,0.8));
        }

        .center-button {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 70px; height: 70px;
            background: radial-gradient(circle, #ffffff 0%, #a0a0a0 100%);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255,255,255,0.5), inset 0 0 10px #000;
            z-index: 50;
            font-weight: 900; color: #111;
            border: 4px solid #333;
            user-select: none;
            font-size: 14px;
        }
        .center-button:active { transform: translate(-50%, -50%) scale(0.95); }
        .center-button.disabled { filter: grayscale(1); cursor: not-allowed; }

        /* Cyberpunk Result Box */
        .result-box {
            margin-top: 20px;
            font-size: 2.5rem;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            min-height: 60px;
            text-align: center;
        }

        /* Controls Area */
        .controls {
            margin-top: 20px;
            text-align: center;
            width: 90%; max-width: 400px;
        }
        .cyber-btn {
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            border: none; padding: 15px 25px;
            color: #000; font-weight: bold; font-family: 'Orbitron';
            cursor: pointer; display: none; margin-top: 10px;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
        }
        .link-output {
            background: rgba(0,0,0,0.8);
            border: 1px solid #00ffff;
            padding: 15px; margin-top: 15px;
            display: none; word-break: break-all;
            color: #00ff00; font-family: monospace;
        }

    </style>
</head>
<body>
<!-- Warp Speed Navigation Effect -->
<div id="warp-overlay" class="warp-overlay">
    <div class="warp-lines"></div>
</div>



    <canvas id="particleCanvas"></canvas>

    <div class="result-box" id="resultDisplay"></div>

    <div class="wheel-wrapper">
        <canvas id="wheelCanvas" width="600" height="600"></canvas>
        <div id="spinBtn" class="center-button" onclick="startSpin()">SPIN</div>
    </div>

    <div class="controls">
        <button id="finishBtn" class="cyber-btn" onclick="generateResultsLink()">
            TRANSMIT RESULTS
        </button>

        <div id="outputArea" class="link-output">
            <div style="color:#aaa; margin-bottom:5px;">Secure Data Link:</div>
            <code id="resultUrlText"></code>
            <button onclick="copyToClipboard()" style="margin-top:10px; background:#333; color:white; border:1px solid #fff; padding:5px;">COPY</button>
        </div>
    </div>

    <script>
        // --- 1. PARTICLE BACKGROUND ---
        const pCanvas = document.getElementById('particleCanvas');
        const pCtx = pCanvas.getContext('2d');
        let particles = [];
        function resizeP() { pCanvas.width = window.innerWidth; pCanvas.height = window.innerHeight; }
        window.addEventListener('resize', resizeP);
        resizeP();
        class Particle {
            constructor() {
                this.x = Math.random() * pCanvas.width;
                this.y = Math.random() * pCanvas.height;
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = (Math.random() - 0.5) * 0.3;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                if(this.x<0||this.x>pCanvas.width) this.vx*=-1;
                if(this.y<0||this.y>pCanvas.height) this.vy*=-1;
            }
            draw() {
                pCtx.fillStyle = 'rgba(255,255,255,0.3)';
                pCtx.beginPath(); pCtx.arc(this.x, this.y, Math.random()*2, 0, Math.PI*2); pCtx.fill();
            }
        }
        for(let i=0;i<40;i++) particles.push(new Particle());
        function animP() {
            pCtx.clearRect(0,0,pCanvas.width,pCanvas.height);
            particles.forEach(p=>{
                p.update(); p.draw();
                particles.forEach(p2=>{
                    let d = Math.hypot(p.x-p2.x, p.y-p2.y);
                    if(d<120) {
                        pCtx.strokeStyle=`rgba(0,255,255,${0.1-d/1200})`;
                        pCtx.beginPath(); pCtx.moveTo(p.x,p.y); pCtx.lineTo(p2.x,p2.y); pCtx.stroke();
                    }
                });
            });
            requestAnimationFrame(animP);
        }
        animP();

        // --- 2. WHEEL LOGIC (Animation Frame based) ---
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        const colors = ['#FF0055', '#0033FF', '#FFCC00', '#00CC99', '#9900FF', '#FF6600'];
        
        let segments = [];
        let spinHistory = [];
        
        // Physics variables
        let currentRotation = 0; // Total degrees rotated (keep increasing)
        let targetRotation = 0;  // Where we want to end up
        let isSpinning = false;
        let speed = 0;           // Current speed in degrees/frame
        
        // Ticker Animation Variables
        let tickerAngle = 0;     // The rotation of the red arrow
        
        function init() {
            const urlParams = new URLSearchParams(window.location.search);
            const options = urlParams.get('options');
            if (options) {
                segments = options.split(',').map(s => s.trim());
            } else {
                segments = ["Error", "Load", "Setup"];
            }
            // Start the visual loop
            requestAnimationFrame(gameLoop);
        }

        function startSpin() {
            if (isSpinning) return;
            document.getElementById('outputArea').style.display = 'none';
            document.getElementById('resultDisplay').innerText = "";
            
            isSpinning = true;
            // Determine random extra rotation (between 5 and 10 full spins)
            const extraSpins = 360 * (5 + Math.random() * 5) + Math.random() * 360;
            targetRotation = currentRotation + extraSpins;
            
            // Simple ease-out logic: We set a high initial speed, and dampen it
            // Actually, let's just use a physics approach in the loop
        }

        function gameLoop() {
            updatePhysics();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function updatePhysics() {
            if (isSpinning) {
                // Distance to target
                const distance = targetRotation - currentRotation;
                
                // If we are far, speed up or maintain max speed. If close, slow down.
                // Simple easing: speed is proportional to distance
                const desiredSpeed = distance * 0.05; 
                
                // Cap max speed so it doesn't look like a blur
                speed = Math.min(desiredSpeed, 30);
                
                // Stop condition
                if (distance < 0.1) {
                    isSpinning = false;
                    currentRotation = targetRotation;
                    finishSpin();
                } else {
                    // Ensure minimum speed so it doesn't stall indefinitely at the end
                    if(speed < 0.1 && distance > 0) speed = 0.1;
                    currentRotation += speed;
                }
            }
            
            // --- TICKER LOGIC ---
            // Calculate where the wheel is relative to a "slice boundary"
            const sliceSize = 360 / segments.length;
            // Where are we in the current circle (0-360)
            // We use (270 + rotation) because the pointer is at 270 (Top)
            // But actually, we just need to know if a "wall" passes the top.
            // The walls are at: index * sliceSize.
            // The top is at: 270 degrees. 
            // Relative rotation at top: (currentRotation + 270)
            
            const position = (currentRotation + 270) % 360;
            const positionInSlice = position % sliceSize;
            
            // If we are very close to the end of a slice (passing a peg)
            // Trigger the kick.
            // Say slice is 60deg. If pos is 58, 59, 0, 1, 2...
            
            // Simpler visual trick:
            // If positionInSlice is near 0, kick the needle.
            // We want the needle to go UP (negative rotation) when hit
            
            if (positionInSlice < 15 && speed > 0.5) {
                // We are passing a peg.
                // Calculate kick intensity based on speed
                let kick = -25 * (speed / 30); // Max kick -25deg
                if (kick < -40) kick = -40;
                
                // Smoothly move towards the kick angle
                tickerAngle += (kick - tickerAngle) * 0.5;
            } else {
                // Return to 0 (gravity)
                tickerAngle += (0 - tickerAngle) * 0.2;
            }
        }

        function draw() {
            const width = canvas.width;
            const center = width / 2;
            const radius = width / 2 - 30; // Room for outer pegs
            const arcSize = (2 * Math.PI) / segments.length;

            ctx.clearRect(0, 0, width, width);

            ctx.save();
            ctx.translate(center, center);
            
            // Rotate the entire canvas to simulate wheel spin
            // We rotate by NEGATIVE currentRotation because canvas rotates clockwise
            // and we usually visualize spin that way.
            ctx.rotate((currentRotation * Math.PI) / 180);

            // 1. Draw Segments
            segments.forEach((segment, index) => {
                const angle = index * arcSize;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, radius, angle, angle + arcSize);
                ctx.fillStyle = colors[index % colors.length];
                ctx.fill();
                ctx.strokeStyle = "rgba(0,0,0,0.5)";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Text
                ctx.save();
                ctx.rotate(angle + arcSize / 2);
                ctx.textAlign = "right";
                ctx.fillStyle = "white";
                ctx.font = "bold 28px Orbitron";
                ctx.shadowColor = "black";
                ctx.shadowBlur = 5;
                ctx.fillText(segment, radius - 40, 10);
                ctx.restore();
            });

            // 2. Draw Outer Rim & Pegs
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.lineWidth = 20;
            ctx.strokeStyle = "#222";
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.lineWidth = 4;
            ctx.strokeStyle = "#00ffff"; // Neon line
            ctx.stroke();

            // Draw Pegs
            segments.forEach((_, index) => {
                const angle = index * arcSize;
                const pegX = (radius) * Math.cos(angle);
                const pegY = (radius) * Math.sin(angle);
                
                ctx.beginPath();
                ctx.arc(pegX, pegY, 8, 0, Math.PI * 2);
                ctx.fillStyle = "white";
                ctx.shadowColor = "white";
                ctx.shadowBlur = 10;
                ctx.fill();
            });

            ctx.restore(); // Undo wheel rotation
            
            // 3. Draw Center Cap (Static)
            ctx.beginPath();
            ctx.arc(center, center, 45, 0, Math.PI * 2);
            ctx.fillStyle = "#111";
            ctx.fill();
            ctx.lineWidth = 4;
            ctx.strokeStyle = "#fff";
            ctx.stroke();

            // 4. Draw The Ticker (Animated)
            // The ticker sits at the TOP (12 o'clock).
            ctx.save();
            ctx.translate(center, 30); // Move to top center
            
            // Apply the "Tick" rotation
            ctx.rotate((tickerAngle * Math.PI) / 180);

            // Draw the Rigid Arrow
            ctx.beginPath();
            ctx.moveTo(-15, -20); // Top Left
            ctx.lineTo(15, -20);  // Top Right
            ctx.lineTo(0, 40);    // Point
            ctx.closePath();
            ctx.fillStyle = "#ff0055"; // Cyber Red
            ctx.shadowColor = "#ff0055";
            ctx.shadowBlur = 15;
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
        }

        function finishSpin() {
            const sliceSize = 360 / segments.length;
            // Calculate winner based on TOP position (270deg)
            // We use (270 + rotation) % 360 to find the angle under the needle
            const finalAngle = (270 + currentRotation) % 360;
            
            // Convert to index
            const winningIndex = Math.floor(finalAngle / sliceSize);
            
            // IMPORTANT: Due to array mapping vs circle drawing direction,
            // we sometimes need to invert logic.
            // Let's test: If rotation is 0. 270 is top. That's index 3 in a 4-slice wheel.
            // Let's stick to the mapped index.
            
            const text = segments[winningIndex];
            
            document.getElementById('resultDisplay').innerText = text;
            spinHistory.push(text);
            
            const btn = document.getElementById('finishBtn');
            btn.style.display = "inline-block";
            btn.innerText = `TRANSMIT RESULTS (${spinHistory.length})`;
        }

        function generateResultsLink() {
            const dataString = encodeURIComponent(JSON.stringify(spinHistory));
            const currentPath = window.location.pathname;
            const directory = currentPath.substring(0, currentPath.lastIndexOf('/'));
            const baseURL = window.location.origin + directory + "/results.html";
            const fullURL = `${baseURL}?data=${dataString}`;

            document.getElementById('resultUrlText').innerText = fullURL;
            document.getElementById('outputArea').style.display = 'block';
        }

        function copyToClipboard() {
            const linkText = document.getElementById('resultUrlText').innerText;
            navigator.clipboard.writeText(linkText);
            alert("Link copied to clipboard.");
        }

        init();
    </script>
</body>
</html>
